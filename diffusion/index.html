<html>

  <style>
    body{
      left:0px;
      top:0px;
      margin:0px;
    }
  </style>
  <body>

<script src="../lib/three.js"                 ></script>
<script src="../lib/jquery.min.js"            ></script>
<script src="../lib/TrackballControls.js"     ></script>
<script src="../lib/ShaderLoader.js"          ></script>
<script src="../lib/PhysicsRenderer.js"       ></script>
<script src="../lib/Stream.js"                ></script>
<script src="../lib/AudioController.js"       ></script>
<script src="../lib/AudioTexture.js"          ></script>
<script src="../lib/ObjectControls.js"        ></script>

<script>

    var scene, camera, renderer;
    var geometry, material, mesh;
    var controls;

    var crystals = [];

    var loaded = 0;
    var neededToLoad = 5;

    var shaders = new ShaderLoader('../shaders');

    shaders.load( 'fs-diffusion' , 'diffusion' , 'fragment' );
    shaders.load( 'vs-diffusion' , 'diffusion' , 'vertex' );
    shaders.load( 'ss-diffusion3' , 'diffusion' , 'simulation' );

    shaders.shaderSetLoaded = function(){

      onLoad();
    }

    var mouse = [0,0];

    var l = THREE.ImageUtils.loadTexture;
    var m = THREE.UVMapping;
    var c = function(){
      onLoad();
    }


    t_og      = l( '../img/logo.png'            , m , c );
    t_matcap  = l( '../img/rough-aluminium.jpg' , m , c );
    t_rainbow = l( '../img/rainbow.png'         , m , c );
    t_block   = l( '../img/logo.png'            , m , c );

    var audioController = new AudioController();

    var uniforms = {
  
      t_og:{ type:"t" , value: t_og }, 
      t_block:{ type:"t" , value: t_block },
      t_audio : { type:"t" , value: audioController.texture     },
      time:{ type:"f" , value:0 } ,
      dT:{ type:"f" , value:0 },
      lightPos:{ type:"v3" , value:new THREE.Vector3()}

    }

    var tick = 0;

    var audio = new Audio(),
    
    // `stream_url` you'd get from 
    // requesting http://api.soundcloud.com/tracks/6981096.json
    url = 'http://api.soundcloud.com/tracks/41923072/stream' +
          '?client_id=2400df97862fa2c06f486af524e4f974';

    audio.src = url;

    var source = audioController.ctx.createMediaElementSource(audio);
    source.connect(audioController.gain);


    function init() {

        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 );
        camera.position.z = 50;

        objectControls = new ObjectControls( camera );
        controls = new THREE.TrackballControls( camera );


        clock = new THREE.Clock();
        renderer = new THREE.WebGLRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );


        
        var size = 1024;
        var ss = shaders.setValue( shaders.ss.diffusion , 'SIZE' , 1./size );


        crystalSim = new PhysicsRenderer( size , ss , renderer );
        crystalSim.setUniform( 't_og' , uniforms.t_og  );
        crystalSim.setUniform( 't_block' , uniforms.t_block  );
        crystalSim.setUniform( 'time' , uniforms.time  );
        crystalSim.setUniform( 'dT' , uniforms.dT  );
        crystalSim.reset( t_og );
       // crystalSim.debug( scene );

        var u ={
          t_crystal: { type:"t" , value:t_og },
          t_matcap: { type:"t" , value:t_matcap },
          t_rainbow: { type:"t" , value:t_rainbow },
          depth: { type:"f" , value: .01 },
          t_og: uniforms.t_og,
          t_audio: uniforms.t_audio,
          lightPos: uniforms.lightPos
        }


        var a = {
          position1:{type:"v3" , value:null},
          position2:{type:"v3" , value:null},
        }


        var vs = shaders.setValue( shaders.vs.diffusion , 'SIZE' , 1./size );
        
        var mat = new THREE.ShaderMaterial({

          uniforms:  u,
          attributes: a,
          vertexShader:  vs,
          fragmentShader: shaders.fs.diffusion,
          side: THREE.DoubleSide,
          transparent: true,

        });

        var geo = createGeo( size /2 );
        var plane = new THREE.Mesh(
          geo,
          mat
          );

          plane.frustumCulled = false;


        intersectPlane = new THREE.Mesh(
          new THREE.PlaneGeometry( 1000000 , 1000000 ),
          new THREE.MeshNormalMaterial()
          );

        intersectPlane.intersectedUpdate = function(oc){

          var p = oc.getPoint( this );
          intersectMesh.position.copy( p );
          uniforms.lightPos.value.copy( p );
          //console.log( this );

        }

        intersectMesh = new THREE.Mesh( 
          new THREE.IcosahedronGeometry( .3 , 1 ),
          new THREE.MeshNormalMaterial()
        );


        objectControls.add( intersectPlane );
        scene.add( intersectMesh );



        intersectPlane.position.z = 10;


       // scene.add( intersectPlane );



        crystalSim.addBoundTexture( plane , 't_crystal' , 'output' );
       
        scene.add( plane );
        //source.mediaElement.play();

       
        window.addEventListener( 'resize', onWindowResize , false );

        document.body.appendChild( renderer.domElement );

    }

    function animate() {

      tick ++;

      requestAnimationFrame( animate );


      objectControls.update();
      audioController.update();
      
      uniforms.dT.value = clock.getDelta();
      uniforms.time.value += uniforms.dT.value;


   //   if( tick % 10 == 0 ){
        crystalSim.update();
    //  }

      controls.update();
       // mesh.rotation.x += 0.01;
       // mesh.rotation.y += 0.02;

      renderer.render( scene, camera );

    }

      // Resets the renderer to be the proper size
    function onWindowResize(){

      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();



      renderer.setSize( window.innerWidth, window.innerHeight );
     
      var dpr = devicePixelRatio || 1;

      //camUniforms.SS.value.x = window.innerWidth * dpr;
      //camUniforms.SS.value.y = window.innerHeight * dpr;


    }




    function createGeo(size ){

      s2 = size * size;
      var positions = new Float32Array( s2 * 3 * 6 );
      var positions1 = new Float32Array( s2 * 3 * 6 );
      var positions2 = new Float32Array( s2 * 3 * 6 );
      //var displacment = new Float32Array[ s2 ];


      var geo = new THREE.BufferGeometry();
      var aPos = new THREE.BufferAttribute( positions , 3 );
      var aPos1 = new THREE.BufferAttribute( positions1 , 3 );
      var aPos2 = new THREE.BufferAttribute( positions2 , 3 );
      
      geo.addAttribute( 'position' , aPos ); 
      geo.addAttribute( 'position1', aPos1 ); 
      geo.addAttribute( 'position2', aPos2 ); 
      
      for( var i =0; i < size; i++ ){
        for( var j = 0; j < size; j++ ){


          var lu  = [ i / (size+1) , j / (size+1) ];
          var ru  = [ (i+1) / (size+1) , j / (size+1) ];
          var rd  = [ (i+1) / (size+1) , (j+1) / (size+1) ];
          var ld  = [ i / (size+1) , (j+1) / (size+1) ];

          
          var id = i * size + j;


          // Triangle 1
          positions[ id * 3 * 6 + 0 ] = lu[0]; 
          positions[ id * 3 * 6 + 1 ] = lu[1]; 
          positions[ id * 3 * 6 + 2 ] = 0;

          positions[ id * 3 * 6 + 3 ] = ld[0]; 
          positions[ id * 3 * 6 + 4 ] = ld[1]; 
          positions[ id * 3 * 6 + 5 ] = 0;

          positions[ id * 3 * 6 + 6 ] = ru[0]; 
          positions[ id * 3 * 6 + 7 ] = ru[1]; 
          positions[ id * 3 * 6 + 8 ] = 0;


          positions1[ id * 3 * 6 + 0 ] = ld[0]; 
          positions1[ id * 3 * 6 + 1 ] = ld[1]; 
          positions1[ id * 3 * 6 + 2 ] = 0;

          positions1[ id * 3 * 6 + 3 ] = ru[0]; 
          positions1[ id * 3 * 6 + 4 ] = ru[1]; 
          positions1[ id * 3 * 6 + 5 ] = 0;

          positions1[ id * 3 * 6 + 6 ] = lu[0]; 
          positions1[ id * 3 * 6 + 7 ] = lu[1]; 
          positions1[ id * 3 * 6 + 8 ] = 0;

          positions2[ id * 3 * 6 + 0 ] = ru[0]; 
          positions2[ id * 3 * 6 + 1 ] = ru[1]; 
          positions2[ id * 3 * 6 + 2 ] = 0;

          positions2[ id * 3 * 6 + 3 ] = lu[0]; 
          positions2[ id * 3 * 6 + 4 ] = lu[1]; 
          positions2[ id * 3 * 6 + 5 ] = 0;

          positions2[ id * 3 * 6 + 6 ] = ld[0]; 
          positions2[ id * 3 * 6 + 7 ] = ld[1]; 
          positions2[ id * 3 * 6 + 8 ] = 0;


          // Triangle 2
          positions[ id * 3 * 6 + 9  ] = ld[0]; 
          positions[ id * 3 * 6 + 10 ] = ld[1]; 
          positions[ id * 3 * 6 + 11 ] = 0;

          positions[ id * 3 * 6 + 12 ] = rd[0]; 
          positions[ id * 3 * 6 + 13 ] = rd[1]; 
          positions[ id * 3 * 6 + 14 ] = 0;

          positions[ id * 3 * 6 + 15 ] = ru[0]; 
          positions[ id * 3 * 6 + 16 ] = ru[1]; 
          positions[ id * 3 * 6 + 17 ] = 0;


          positions1[ id * 3 * 6 + 9  ] = rd[0]; 
          positions1[ id * 3 * 6 + 10 ] = rd[1]; 
          positions1[ id * 3 * 6 + 11 ] = 0;

          positions1[ id * 3 * 6 + 12 ] = ru[0]; 
          positions1[ id * 3 * 6 + 13 ] = ru[1]; 
          positions1[ id * 3 * 6 + 14 ] = 0;

          positions1[ id * 3 * 6 + 15 ] = ld[0]; 
          positions1[ id * 3 * 6 + 16 ] = ld[1]; 
          positions1[ id * 3 * 6 + 17 ] = 0;


          positions2[ id * 3 * 6 + 9  ] = ru[0]; 
          positions2[ id * 3 * 6 + 10 ] = ru[1]; 
          positions2[ id * 3 * 6 + 11 ] = 0;

          positions2[ id * 3 * 6 + 12 ] = ld[0]; 
          positions2[ id * 3 * 6 + 13 ] = ld[1]; 
          positions2[ id * 3 * 6 + 14 ] = 0;

          positions2[ id * 3 * 6 + 15 ] = rd[0]; 
          positions2[ id * 3 * 6 + 16 ] = rd[1]; 
          positions2[ id * 3 * 6 + 17 ] = 0;


        }
      }

      return geo; 

    }

    function onLoad(){

      loaded ++;
      if( loaded == neededToLoad ){

        init();
        animate();

      }

    }
  </script>

</body>
</html>
